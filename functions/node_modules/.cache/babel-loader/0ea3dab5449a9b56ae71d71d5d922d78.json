{"ast":null,"code":"const EventEmitter = require('events').EventEmitter;\n\nconst stream = require('stream');\n\nconst EVENT_BATCH = 'batch';\nconst EVENT_CHANGE = 'change';\nconst EVENT_SEQ = 'seq';\nconst EVENT_ERROR = 'error'; // streaming line breaker\n\nconst liner = () => {\n  const liner = new stream.Transform({\n    objectMode: true\n  });\n\n  liner._transform = function (chunk, encoding, done) {\n    let data = chunk.toString('utf8');\n\n    if (this._lastLineData) {\n      data = this._lastLineData + data;\n      this._lastLineData = null;\n    }\n\n    const lines = data.split(/\\s*\\n/);\n    this._lastLineData = lines.splice(lines.length - 1, 1)[0];\n    lines.forEach(this.push.bind(this));\n    done();\n  };\n\n  liner._flush = function (done) {\n    this.push(this._lastLineData);\n    this._lastLineData = null;\n    done();\n  };\n\n  return liner;\n}; // streaming change processor\n\n\nconst changeProcessor = (ee, batchSize) => {\n  const changeProcessor = new stream.Transform({\n    objectMode: true\n  });\n  const buffer = [];\n  changeProcessor.lastSeq = '0';\n\n  changeProcessor._transform = function (chunk, encoding, done) {\n    // remove last char from string\n    if (chunk[chunk.length - 1] === ',') {\n      chunk = chunk.slice(0, -1);\n    }\n\n    try {\n      const j = JSON.parse(chunk);\n      buffer.push(j);\n\n      if (buffer.length >= batchSize) {\n        ee.emit(EVENT_BATCH, buffer.splice(0, batchSize));\n      }\n\n      done();\n    } catch (e) {\n      // look for last_seq\n      const match = chunk.match(/\"last_seq\":(.+?)[},]/);\n\n      if (match) {\n        changeProcessor.lastSeq = JSON.parse(match[1]);\n      }\n\n      done();\n    }\n  };\n\n  changeProcessor._flush = function (done) {\n    if (buffer.length > 0) {\n      ee.emit(EVENT_BATCH, buffer.splice(0, buffer.length));\n    }\n\n    done();\n  };\n\n  return changeProcessor;\n};\n/**\n * Monitors the changes feed (after calling .start()/.get()) and emits events\n *  - EVENT_CHANGE - per change\n *  - EVENT_BATCH - per batch of changes\n *  - EVENT_SEQ - per change of sequence number\n *  - EVENT_ERROR - per 4xx error (except 429)\n *\n * @param {String} db - Name of the database.\n * @param {Function} request - Nano.relax\n */\n\n\nclass ChangesReader {\n  // constructor\n  constructor(db, request) {\n    this.db = db;\n    this.setDefaults();\n    this.request = request;\n  } // set defaults\n\n\n  setDefaults() {\n    this.ee = new EventEmitter();\n    this.batchSize = 100;\n    this.fastChanges = false;\n    this.since = 'now';\n    this.includeDocs = false;\n    this.timeout = 60000;\n    this.started = false;\n    this.wait = false;\n    this.stopOnEmptyChanges = false; // whether to stop polling if we get an empty set of changes back\n\n    this.continue = true; // whether to poll again\n\n    this.qs = {}; // extra querystring parameters\n\n    this.selector = null;\n    this.paused = false;\n  }\n\n  pause() {\n    this.paused = true;\n  }\n\n  resume() {\n    this.paused = false;\n  } // prevent another poll happening\n\n\n  stop() {\n    this.continue = false;\n  } // sleep, promise style\n\n\n  async sleep(t) {\n    return new Promise((resolve, reject) => {\n      setTimeout(resolve, t);\n    });\n  } // called to start listening to the changes feed. The opts object can contain:\n  // - batchSize - the number of records to return per HTTP request\n  // - since - the the sequence token to start from (defaults to 'now')\n\n\n  start(opts) {\n    const self = this; // if we're already listening for changes\n\n    if (self.started) {\n      // return the existing event emitter\n      return self.ee;\n    }\n\n    self.started = true; // handle overidden defaults\n\n    opts = opts || {};\n    Object.assign(self, opts); // the work function is async and runs in the background\n    // with a big do/while loop\n\n    let delay = 0;\n\n    const work = async () => {\n      do {\n        if (!self.paused) {\n          // formulate changes feed longpoll HTTP request\n          const req = {\n            method: 'post',\n            db: self.db,\n            path: '_changes',\n            qs: {\n              feed: 'longpoll',\n              timeout: self.timeout,\n              since: self.since,\n              limit: self.batchSize,\n              include_docs: self.includeDocs\n            },\n            body: {}\n          };\n\n          if (self.fastChanges) {\n            req.qs.seq_interval = self.batchSize;\n          }\n\n          if (self.selector) {\n            req.qs.filter = '_selector';\n            req.body.selector = self.selector;\n          }\n\n          Object.assign(req.qs, opts.qs); // make HTTP request to get up to batchSize changes from the feed\n\n          try {\n            const data = await self.request(req);\n            delay = 0; // update the since state\n\n            if (data && data.last_seq && data.last_seq !== self.since) {\n              self.since = data.last_seq;\n              self.ee.emit(EVENT_SEQ, self.since);\n            } // stop on empty batch\n\n\n            if (self.stopOnEmptyChanges && data && typeof data.results !== 'undefined' && data.results.length === 0) {\n              self.continue = false;\n            } // if we have data\n\n\n            if (data && data.results && data.results.length > 0) {\n              // emit EVENT_CHANGE events\n              for (const i in data.results) {\n                self.ee.emit(EVENT_CHANGE, data.results[i]);\n              } // in 'wait' mode, we need to wait until the user calls .resume()\n\n\n              if (self.wait) {\n                // so call pause() to prevent further API calls until .resume() is called\n                self.pause();\n              } // emit EVENT_BATCH event\n\n\n              self.ee.emit(EVENT_BATCH, data.results);\n            }\n          } catch (err) {\n            // error (wrong password, bad since value etc)\n            // if the error is fatal\n            if (err && err.statusCode && err.statusCode >= 400 && err.statusCode !== 429 && err.statusCode < 500) {\n              self.continue = false;\n            } else {\n              // don't immediately retry on error - exponential back-off\n              delay = delay ? Math.max(60000, delay * 2) : 5000;\n            }\n\n            self.ee.emit(EVENT_ERROR, err);\n          }\n        } // if in pause mode, wait 100ms before checking again\n\n\n        if (self.paused && delay === 0) {\n          delay = 100;\n        } // delay before next request?\n\n\n        if (self.continue && delay > 0) {\n          await self.sleep(delay);\n        }\n      } while (self.continue); // reset\n\n\n      self.ee.emit('end', self.since);\n      self.setDefaults();\n    };\n\n    work(); // return the event emitter to the caller\n\n    return self.ee;\n  } // called to start listening to the changes feed for a finite number of changes. The opts object can contain:\n  // - batchSize - the number of records to return per HTTP request\n  // - since - the sequence token to start from (defaults to 'now')\n\n\n  get(opts) {\n    this.stopOnEmptyChanges = true;\n    return this.start(opts);\n  } // called to spool through changes to \"now\" in one long HTTP request\n\n\n  spool(opts) {\n    const self = this;\n    self.setDefaults();\n    opts = opts || {};\n    Object.assign(self, opts);\n    const req = {\n      method: 'post',\n      db: self.db,\n      path: '_changes',\n      qs: {\n        since: self.since,\n        include_docs: self.includeDocs,\n        seq_interval: self.batchSize\n      },\n      stream: true,\n      body: {}\n    };\n\n    if (self.selector) {\n      req.qs.filter = '_selector';\n      req.body.selector = self.selector;\n    }\n\n    const lin = liner();\n    const cp = changeProcessor(self.ee, self.batchSize);\n    self.request(req).pipe(lin).pipe(cp).on('finish', lastSeq => {\n      // the 'end' event was triggering before the last data event\n      setTimeout(() => {\n        self.ee.emit('end', cp.lastSeq);\n      }, 10);\n    }).on(EVENT_ERROR, e => {\n      self.ee.emit(EVENT_ERROR, e);\n    });\n    return self.ee;\n  }\n\n}\n\nmodule.exports = ChangesReader;","map":{"version":3,"sources":["C:/Programowanie/store/node_modules/nano/lib/changesreader.js"],"names":["EventEmitter","require","stream","EVENT_BATCH","EVENT_CHANGE","EVENT_SEQ","EVENT_ERROR","liner","Transform","objectMode","_transform","chunk","encoding","done","data","toString","_lastLineData","lines","split","splice","length","forEach","push","bind","_flush","changeProcessor","ee","batchSize","buffer","lastSeq","slice","j","JSON","parse","emit","e","match","ChangesReader","constructor","db","request","setDefaults","fastChanges","since","includeDocs","timeout","started","wait","stopOnEmptyChanges","continue","qs","selector","paused","pause","resume","stop","sleep","t","Promise","resolve","reject","setTimeout","start","opts","self","Object","assign","delay","work","req","method","path","feed","limit","include_docs","body","seq_interval","filter","last_seq","results","i","err","statusCode","Math","max","get","spool","lin","cp","pipe","on","module","exports"],"mappings":"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","sourcesContent":["const EventEmitter = require('events').EventEmitter\nconst stream = require('stream')\nconst EVENT_BATCH = 'batch'\nconst EVENT_CHANGE = 'change'\nconst EVENT_SEQ = 'seq'\nconst EVENT_ERROR = 'error'\n\n// streaming line breaker\nconst liner = () => {\n  const liner = new stream.Transform({ objectMode: true })\n\n  liner._transform = function (chunk, encoding, done) {\n    let data = chunk.toString('utf8')\n    if (this._lastLineData) {\n      data = this._lastLineData + data\n      this._lastLineData = null\n    }\n\n    const lines = data.split(/\\s*\\n/)\n    this._lastLineData = lines.splice(lines.length - 1, 1)[0]\n    lines.forEach(this.push.bind(this))\n    done()\n  }\n\n  liner._flush = function (done) {\n    this.push(this._lastLineData)\n    this._lastLineData = null\n    done()\n  }\n\n  return liner\n}\n\n// streaming change processor\nconst changeProcessor = (ee, batchSize) => {\n  const changeProcessor = new stream.Transform({ objectMode: true })\n  const buffer = []\n  changeProcessor.lastSeq = '0'\n\n  changeProcessor._transform = function (chunk, encoding, done) {\n    // remove last char from string\n    if (chunk[chunk.length - 1] === ',') {\n      chunk = chunk.slice(0, -1)\n    }\n\n    try {\n      const j = JSON.parse(chunk)\n      buffer.push(j)\n      if (buffer.length >= batchSize) {\n        ee.emit(EVENT_BATCH, buffer.splice(0, batchSize))\n      }\n      done()\n    } catch (e) {\n      // look for last_seq\n      const match = chunk.match(/\"last_seq\":(.+?)[},]/)\n      if (match) {\n        changeProcessor.lastSeq = JSON.parse(match[1])\n      }\n      done()\n    }\n  }\n\n  changeProcessor._flush = function (done) {\n    if (buffer.length > 0) {\n      ee.emit(EVENT_BATCH, buffer.splice(0, buffer.length))\n    }\n    done()\n  }\n\n  return changeProcessor\n}\n\n/**\n * Monitors the changes feed (after calling .start()/.get()) and emits events\n *  - EVENT_CHANGE - per change\n *  - EVENT_BATCH - per batch of changes\n *  - EVENT_SEQ - per change of sequence number\n *  - EVENT_ERROR - per 4xx error (except 429)\n *\n * @param {String} db - Name of the database.\n * @param {Function} request - Nano.relax\n */\nclass ChangesReader {\n  // constructor\n  constructor (db, request) {\n    this.db = db\n    this.setDefaults()\n    this.request = request\n  }\n\n  // set defaults\n  setDefaults () {\n    this.ee = new EventEmitter()\n    this.batchSize = 100\n    this.fastChanges = false\n    this.since = 'now'\n    this.includeDocs = false\n    this.timeout = 60000\n    this.started = false\n    this.wait = false\n    this.stopOnEmptyChanges = false // whether to stop polling if we get an empty set of changes back\n    this.continue = true // whether to poll again\n    this.qs = {} // extra querystring parameters\n    this.selector = null\n    this.paused = false\n  }\n\n  pause () {\n    this.paused = true\n  }\n\n  resume () {\n    this.paused = false\n  }\n\n  // prevent another poll happening\n  stop () {\n    this.continue = false\n  }\n\n  // sleep, promise style\n  async sleep (t) {\n    return new Promise((resolve, reject) => {\n      setTimeout(resolve, t)\n    })\n  }\n\n  // called to start listening to the changes feed. The opts object can contain:\n  // - batchSize - the number of records to return per HTTP request\n  // - since - the the sequence token to start from (defaults to 'now')\n  start (opts) {\n    const self = this\n\n    // if we're already listening for changes\n    if (self.started) {\n      // return the existing event emitter\n      return self.ee\n    }\n    self.started = true\n\n    // handle overidden defaults\n    opts = opts || {}\n    Object.assign(self, opts)\n\n    // the work function is async and runs in the background\n    // with a big do/while loop\n    let delay = 0\n    const work = async () => {\n      do {\n        if (!self.paused) {\n          // formulate changes feed longpoll HTTP request\n          const req = {\n            method: 'post',\n            db: self.db,\n            path: '_changes',\n            qs: {\n              feed: 'longpoll',\n              timeout: self.timeout,\n              since: self.since,\n              limit: self.batchSize,\n              include_docs: self.includeDocs\n            },\n            body: {}\n          }\n          if (self.fastChanges) {\n            req.qs.seq_interval = self.batchSize\n          }\n          if (self.selector) {\n            req.qs.filter = '_selector'\n            req.body.selector = self.selector\n          }\n          Object.assign(req.qs, opts.qs)\n\n          // make HTTP request to get up to batchSize changes from the feed\n          try {\n            const data = await self.request(req)\n            delay = 0\n\n            // update the since state\n            if (data && data.last_seq && data.last_seq !== self.since) {\n              self.since = data.last_seq\n              self.ee.emit(EVENT_SEQ, self.since)\n            }\n\n            // stop on empty batch\n            if (self.stopOnEmptyChanges && data && typeof data.results !== 'undefined' && data.results.length === 0) {\n              self.continue = false\n            }\n\n            // if we have data\n            if (data && data.results && data.results.length > 0) {\n              // emit EVENT_CHANGE events\n              for (const i in data.results) {\n                self.ee.emit(EVENT_CHANGE, data.results[i])\n              }\n\n              // in 'wait' mode, we need to wait until the user calls .resume()\n              if (self.wait) {\n                // so call pause() to prevent further API calls until .resume() is called\n                self.pause()\n              }\n\n              // emit EVENT_BATCH event\n              self.ee.emit(EVENT_BATCH, data.results)\n            }\n          } catch (err) {\n            // error (wrong password, bad since value etc)\n            // if the error is fatal\n            if (err && err.statusCode && err.statusCode >= 400 && err.statusCode !== 429 && err.statusCode < 500) {\n              self.continue = false\n            } else {\n              // don't immediately retry on error - exponential back-off\n              delay = delay ? Math.max(60000, delay * 2) : 5000\n            }\n\n            self.ee.emit(EVENT_ERROR, err)\n          }\n        }\n\n        // if in pause mode, wait 100ms before checking again\n        if (self.paused && delay === 0) {\n          delay = 100\n        }\n\n        // delay before next request?\n        if (self.continue && delay > 0) {\n          await self.sleep(delay)\n        }\n      } while (self.continue)\n\n      // reset\n      self.ee.emit('end', self.since)\n      self.setDefaults()\n    }\n    work()\n\n    // return the event emitter to the caller\n    return self.ee\n  }\n\n  // called to start listening to the changes feed for a finite number of changes. The opts object can contain:\n  // - batchSize - the number of records to return per HTTP request\n  // - since - the sequence token to start from (defaults to 'now')\n  get (opts) {\n    this.stopOnEmptyChanges = true\n    return this.start(opts)\n  }\n\n  // called to spool through changes to \"now\" in one long HTTP request\n  spool (opts) {\n    const self = this\n    self.setDefaults()\n    opts = opts || {}\n    Object.assign(self, opts)\n    const req = {\n      method: 'post',\n      db: self.db,\n      path: '_changes',\n      qs: {\n        since: self.since,\n        include_docs: self.includeDocs,\n        seq_interval: self.batchSize\n      },\n      stream: true,\n      body: {}\n    }\n    if (self.selector) {\n      req.qs.filter = '_selector'\n      req.body.selector = self.selector\n    }\n    const lin = liner()\n    const cp = changeProcessor(self.ee, self.batchSize)\n    self.request(req)\n      .pipe(lin)\n      .pipe(cp)\n      .on('finish', (lastSeq) => {\n        // the 'end' event was triggering before the last data event\n        setTimeout(() => {\n          self.ee.emit('end', cp.lastSeq)\n        }, 10)\n      })\n      .on(EVENT_ERROR, (e) => {\n        self.ee.emit(EVENT_ERROR, e)\n      })\n\n    return self.ee\n  }\n}\n\nmodule.exports = ChangesReader\n"]},"metadata":{},"sourceType":"script"}